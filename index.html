#20

Making solid progress. I've got the initial stream of a fully valid request
coming through properly, and have implemented JSON schema to ensure the request
is actually valid. Seems to be working swimmingly. The first thing I want to do
next session is refactore things a bit so this is a cleaner looking process.
Since it is mostly functional programming, adjusting the process is WAY faster
than regular imperative programming and it has been really great and fast to
adjust things. Refactoring should go swimmingly. Totally excited.


#19

Getting close, so I spent a bit of time debugging because I kept trying to use
`RxJS` 5... `Inquirer` doesn't like that, so I guess I'm stuck with `RxJS` 4.
Lame, I will probably replace the prompting system in the future, but for now
I'll deal I guess. Now that I fixed that, I need to get a system that allows me
to request required parameters if they are missing and then when everything is
said and done, send things through to the end of the command. Time for a break.


#Pre-19

Getting ready to jump into ideally 4 sessions tonight. So the goal is to get the
request validation portion at least basically setup. I want prompts to be used
to fill in the required portions if the required portions aren't already
provided. Hopefully working with `Inquirer` mixed with `rxjs` is smooth going.
We shall see. I saw a post in the past about someone who got infinite prompting
working with `Inquirer` so it should meet my needs at least until I deem
otherwise and can replace it later. This also means that I need to start
considering the program spec and what it will look like. AWAY!!!


#18

So I setup the initial observable stream and have setup the command parsing with
`minimist` and setup detecting the `sub-command` by grabbing the first unlabeled
parameter found by minimist and extracting that from the args as a sub-command.
I've also pulled that process out into a separate command parser so that command
parser can be re-used. The command parser will accept a program specification
which will include the sub-commands and their options and requirements and
stuff. So with that I'll start working on the prompting system that will check
for required parameters and if they don't exist then prompting for them. I also
need to start segmenting the smaller parts of the program, like parsing with
minimist. I want to be able to use the program spec to customize how `minimist`
takes in arguments. For example if a single letter argument is set to a
variable, but the program spec says it is a boolean, then it should extract that
into unlabeled and set the argument to true. Little things like that. Should be
easy. I want to be able to provide a full blown command parser, but I also want
to give people the option to construct their own command parser with each
individual part so I'll be exporting all of them in the module. Should be fairly
powerful.


#Pre-18

So between yesterday and today, I've been considering how to approach building
my own CLI processor in the form of a stream. In order to do that I've had to
think about breaking it up into multiple parts. Some of those parts could be
covered with other tech to make this easier. The first part is parsing out all
of the arguments. This is something that can be done by `minimist`. Next would
be to determine if a subcommand is trying to be run by analyzing the first of
the non-marked arguments (we are making the assumption of a single subcommand
per execution). Then when we know the command we can check against
required/optional parameters for that command, and if we are not running in
detached mode we prompt for each one. If we already have all requirements, don't
prompt for optionals, if we don't have all requirements when prompting for
required, also prompt for optionals. Once we have all the parameters then we
need to call the actual service with it. The service will yield data to intruct
on a side effect, then that data will be passed to the appropriate side effect
(be it file writing, logging, etc.). At any point if requirements are not met
and it "fails", error out and the error will result in showing the help for the
detected subcommand otherwise it will show it for the whole program.

I think I can work with that design. Now to start writing it. I won't have many
sessions today, probably only one. But starting is good.


#17

So it's ridiculous, but I'm working on designing a new CLI processor based on
streams. Seriously the rabbit hole keeps getting deeper and maybe one day I'll
dig myself out. During this project to provide a unified architecture/service
system I'm going to find a lot of things that aren't built to the way that will
enable everything to work, cleanly and in tandem with each other. The thing is,
things have to be converted into a truly data driven system. However I need to
make sure that I'm not restricting myself into a configuration heavy system,
which I don't think will happen considering that being able to stream process
things means that prior to making a call to a data driven system I can massage
the data into what it needs to be in a stream and then merge map into it. I
think... we shall see.


#16

So I'm not satisfied with dashdash or args parse honestly. dashdash set my
expectations for something like bash completion and clean type coercion, but I'm
just not satisfied. I have to walk on this. I was thinking about just using
minimist, but minimist doesn't have nice features like generated help, and what
not. I feel like there should really be an easier way for this, there has got to
be something I'm missing. Do I need to write my own CLI module built in Rx? It's
possible. Since I'm considering everything is a stream. I could use minimist to
parse our the arguments, but design my own system around subcommands, and then
pipe minimist results into a generated help, perhaps? Part of the problem with
minimist is the implicit arguments rather than explicit. I want explicit that
matches the "services" request parameters. Which I sort of liked commander for.
It's all dumb and just doesn't make sense. I'll figure something out. Time for a
walk to clear my mind.


#15

So while using Commander I discovered an unforgiving issue. Apparently if you
have an argument that matches any of the object properties of the commander
object, then you break the Commander object because your argument will replace
that property on Commander instead of being namespaced. There was a suggestion
to move to argsparse, so I'll take a look at that. Actually just looked at
dashdash and I like that he does an analysis of other CLI parsers and has much
better features like bash completion integration and what not... looks solid.
Good to be back and working on STM again after a busy crazy work week.


#14

So I'm dumb. I tried to create the program stream using a Subject instead of
just creating an Observable. So now that I've figured that out I can actually
move forward. I refactored the program into an observable now so I can create
command streams that spin off of that and merge them all together. Making
progress. I setup the help stream that catches when default is sent. The goal is
to figure out the best way to represent commands in a similar way as
representing a service in an HTTP system and then using that representation to
build subcommand around it. The CLI tool acts as an API gateway and the
subcommands are individual services. The arguments are the request parameters so
they can run through the same request validation as an HTTP request. Eventually
I want to see STM building itself... lol. But for now I've got to stop... gotta
go get some work done for my real job now. I'll tackle more soon.


#13

So my brain hurts. Trying to figure out the best way to turn the entire program
into a stream... but that isn't as easy as I thought it might be. If anything it
is giving me more experience with streams, which is something I can't argue
with. It is just frustrating. Ideally I have a directory of services and those
are dynamically loaded into the Commander program with description and
everything while linking to that directory's handler function to do the things,
but that isn't exactly working out the way I want. Looks like I'll have to let
this simmer throughout the day while I do work. Lame... :(


#12

Started exploring what it will take to turn the entire CLI into a stream of
commands and how to properly filter them and send them into eventual "service"
functions. I just want Commander to be an "API Gateway" for commands in a
similar pattern as I would do for the microservices it creates. So it is worth
exploring for a bit. I think I'll try one more session after this so that I can
commit something that works with streams.


#11

Didn't get the chance to work on STM yesterday, but this morning I'm popping in
a couple sessions. But it wasn't the best start. I get perfectionist when it
comes to making things presentable and I need to stop and start working on the
actual command. I just wanted a nice default and got sucked into trying to
figure out the intricacies of Commander. My bad. So next I actually will start
on the prompting system for the initialization of a project. I think I'll only
have one more session though as I need to get some Kasisto work done.


#10

I realized something major just recently, that STM can cover more ground than
was originally planned. I sat down and did a big picture session of design. This
design could lead to big things in the future, but I have to be VERY careful of
scope creep. I'm realizing that there is a lot of parallel in the tasks I'm
doing and a LARGE refactoring in common practices across the tech world is
necessary. A lot of tools that exist need to be rebuilt to handle this
refactoring, but it will be better in the end. This was a very interesting
session to say the least. I'd share, but then I can't build it myself. I'm more
than willing to be transparent, but I want to be able to take the time to build
the philosophy first.


#9

Started playing around with the help display of the command. Had to figure out
how to do a banner above the help output added in some indentation and what not.
My first main goal is to make sure that the documentation for this system is
clean and easy to parse. It needs to be intuitive and documented from the
beginning.


#8

So I've started creating the STM CLI. First thing first is setting up commander.
I also realized that I need to regularly compile my ES6 code into an executable
local STM, so I'm working on setting up a Gulp file now so that I can have my
changes be watched and automatically compiled into an executable and I'll
symlink the executable in the root directory so it is quick to test things
manually. Considering this first portion is just CLI options as input I don't
think I'll want automated testing for this, but when those settings get passed
into the inquirer portion which will handle prompting then I probably want to
look into something automated around there for filling in like defaults that
weren't provided by CLI options. We'll see. Time for the next break.


#7

Day #2 - starting by planning out the first STM command which will be `stm
init`. This will create the project directory structure of "services". "tools",
and "modules" and store the project settings in "./.root.json". These settings
exist to provide a path for idempotency as well as an easy upgrade path so
re-running a command can be re-run with past settings. This will be a common
pattern for all code generation in STM. I also did some research into how I
expect to do testing for STM so it remains stable. This is essentially a more
specific "Slush" so I've been looking into testing for gulp/slush. Hopefully
using a stream system with RxJS will make testing a bit easier. We'll see in the
second session of the day.


#6

Spent some time writing down initial details on STM and planning where to go
from here. Did a lot of research on Commander and Liftoff as well as their
dependencies. Liftoff would be nice to use if I want a config file, but I don't
think I will need one early on since the goal of STM is to provide an
opinionated approach first. Commander will be good to use as it will provide
solid help information that I can utilize as well as parsing of arguments and
parsing of those arguments. I can use those arguments as "pre-filling" in
inquirer prompts. I think I will take one more session of STM planning before
starting to build because I have to think of what commands to start with and how
they will interact. The goal is also to have STM be idempotent for safety sake
of affecting projects, so I'll have to consider how to do that well as well as
consider "upgrade" paths for projects using STM. For now I break for breakfast.


#5

So I've made STM easy to publish and it now is executable. I also had time to
setup babel and es6 with a build pipeline to only publish what I want it to
publish. Sure I could use like npm ignore, but I have to build babel somewhere
so I might as well copy the relevant files to the same distribution folder. Next
I need to look at commander and making STM an actual CLI tool with commands and
everything. I may have to look at other CLI packages and stuff, but commander
will be a good place to start looking.


#4

So I was going to make STM executable, but then realized that I wanted a quick
way to publish STM. I had to play around with a couple of configurations and end
on a simple bash script that runs a `patch` run script and then runs `npm
publish`. I had to do it seprately because prepublish took the version it was
ran with rather than the new version created by the `patch` script. Oh well. So
now I can publish quickly, which means the next session I will make it
installable and executable. Time to learn how to setup a `bin` script for a node
package.


#3

Third session was about setting up the first major product provided by DEX...
STM (https://www.npmjs.com/package/s-t-m). STM stands for "Services, Tools,
Modules" and the goal of it is to be able to build microservice architectures
super quickly... like in an hour and pushed to production. I believe this can be
done efficiently following a specific set of opinionated software engienering
principles without sacrificing quality and flexibility in growth. I think the
next session is trying to get it executable.


#2

Second sesssion now done. I've setup the Github organization, checked various
social media channels to make sure the username of DevelopEXp was available.
Trying to get DEX everywhere would be near impossible so I've settled for
DevelopEXp everywhere. I've also started the public site for this, starting with
a simple HTML webpage. Time for my 5 minute break (working in pomodoro schedule
of 25 on and 5 off).


#1

My first 25 minute session working on DEX included me writing out the initial
ideas, goals, names, etc. in my fancy notebook that I got to build a startup.
I'm excited to start building this idea, 25 minutes at a time and blogging the
whole way through.
