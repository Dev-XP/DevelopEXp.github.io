#38

Learning more about the possibilities with GraphQL schema. It's interesting to
learn and eventually I need to figure out exactly how I'm going to use it in STM
effectively and how I'm going to bring everything together if I plan on allowing
microservice fanciness. If I want a single GraphQL server for each major Domain
object, I still need to define the relationship between them easily while still
providing one very large GraphQL server to query all of the things.


#37

More time diving into GraphQL. Getting more familiar with the schema shorthand
syntax and how it interacts with the rest of GraphQL. It is possible I may want
to do the behaviour based systems in GraphQL instead of RPC, but probably not. I
think I want to leave behaviour out of it and instead focus GraphQL just on
entities and their relationships. However, it would be nice to run an RPC and
then promptly follow that up with grabbing particular properties from the
result. Who knows? I'll have to think more on that. Enjoying the little
exploration if anything.


#36

Been a while since I've done anything with DEX because the craziness of moving
has taken over. But good news, things are relatively stable now and I'll be able
to start regularly contributing once again. Exciting. I also plan on starting up
streaming my coding sessions again soon when we close on our new house so that
will be awesome. This weekend I plan on updating my dot-files and improving my
workflow so I am much faster than I was. For this session I decided to get back
into working by exploring Graph QL. I think GraphQL will be how I will implement
data based services, rather than using REST. I've also taken time today to look
into protocol buffers by Google and there is great similarity there. I think
that using a GraphQL query, a protocol schema could be written to improve the
performance of all calls with that query structure. Could be an interesting use
case, but first I need to learn protobufs and GraphQL. Not to mention I want to
use Event Sourcing in STM as well. So lots to learn. I figured out the RPC
approach for behaviour based services, now I need to learn the stuff that I want
to do around data/resource based services.


#35

Added tests for grabbing request parameters for a command and realized that the
amount of data that I was passing into the command parser was ridiculous and
unnecessary. I was passing this huge object when I only really needed a few
parts of that object. So I changed the interface of the command parser to only
accept the parts that were actually needed and I'll write a converter to morph
the large services object into the needed interface for the command parser.
Testing really helps determine what is the best route for things. Still have
more parts to test and refactor, like adding required parameters into the mix. I
might have to do error handling in `rxt`. I really hope I don't have to.


#34

Alright so I've started filling out tests... but now I have to remember all the
features that I had designed and brought into the command parser. I'm also
learning some things that I want out of my `rxt` testing library as I do this
and I'll have to go upgrade that some time. I'll also probably bring `rxt` under
that umbrella of DEX as a company because it is designed to build test
variations faster. For now I have to fill out the current features that are in
the command parser and switch over to test driven development (probably test
first, but maybe even test after). So that will be my next session, which may be
later today... or it may be tomorrow. We shall see. Finally making quality
progress at least.


#33

Finally finished the damn custom command assertion that I've been working on. It gave
me a better feel for `should.js` at least. It's been the slowest part of getting
testing setup for STM. But now that I have that finally done I can actually
write a bunch of tests. I may have to refactor a bit to take advantage of
variance testing, but we shall see in the next session. I might get one or two
more. But we'll see since Jess just woke up. ;)


#32

I didn't get another session in yesterday, but oh well. This morning while
strolling around on my 30 minute morning walk, I thought of a really cool
product idea that would be useful for Jess and myself in general and could
change an entire industry. So I spent the first session of the day doing
brainstorm in my "spellbook" of ideas and planning and stuff. It's very pretty.
I should find a way to tack on images to logs actually in the future. Would be
fun. Screenshots, pictures of work area, abstract reference images, etc. Perhaps
something to be considered for the DEX Development methodology (the agile
methodology process that I had recently). I need to sit down and brainstorm that
out some time as I do want to model my whole style of development in a formal
way and evolve it as I learn productivity tips and stuff. Going on my 5 minute
break and then I'll jump back into STM and it's testing that I was doing so I
can make some progress on it.


#31

Another day of fun. I'm out in the cold cold morning of Bend, OR at Drake Park
waiting for a sunrise, but I may be in the wrong place. I'm also in short
sleeves and shorts... lol. Anyway, this morning I started playing around with
how to organize the side effects... something I'll have to figure out how to
handle with STM. The main thing is trying to get prompts and retries working. I
may drop the focus on trying to make drafts work for now and get back to
focusing on STM as that has given me some ideas. I think I'll head back to the
hotel and take a shower to think about how I'm going to properly handle this.
Basically if a service doesn't have the right request parameters it can respond
with a `400 BAD REQUEST` with a side effect to prompt for the required
parameters, or one parameter at a time... or something. And after prompting it
should retry with the new adjusted parameters. I may want to return the previous
parameters so that the prompt side effect handler has defaults to fill in or at
least extends those with the new prompt answers to retry the request. I'll think
on that. For now... my hands are a bit freezing and I may just stick around a
little bit to just barely catch the sunrise. It just doesn't look like I'm in a
good position to catch it on this bench.


#30

I'm now able to write blog posts and drafts. The next thing I would want would
be to continue writing drafts and then publishing them later. That would be
nice. For now I've also added drafts to the git ignored files so that way drafts
are completely not "published" even into source control. Continuing a draft will
require me to read the context of the run service and add the drafts file list
to the running of the blog service command and with that context, it can make
decisions. This is helping to inform me on how to handle context with STM so
I'll have to explore the best way to do this for the DEX blog writing portion.
But I may be done with sessions for the day and I'll probably get some more in
tomorrow.


#29

So I'm getting closer with the saving of the blog entries. I've got the prompt
system working properly, and I've got the prompts being converted into a Vinyl
file to be saved to the filesystem. The next thing is to actually save the file
as a side effect. Doing this will get me a bit of experience with Vinyl and
saving files which I will need to do for STM anyway so this is helpful. I'm
looking forward to having this tool as I'll be able to write longer blog posts
now as sessions so I can start writing down my grander thoughts on concepts
which will be quite fun. This is all tying into my new idea to turn the way that
I'm developing STM into a full Agile Development philosophy style similar to
KanBan and Scrum. This style will be called DEX, as it relates to "Agility and
Dexterity". The goal of that style will be based around Pomodoro sessions of 25
minutes, and logging each session. Using that core philosophy I'll build project
management tools and practicies around it like estimations based on sessions,
reporting work, time logging, resource management, etc. I love a lot of the
philosophies of Scrum and Kanban, but I think it can be done better. Pomodoros
have proven to be very powerful for me and I honestly think the way I work is
MUCH faster than your typical agile developer. I want to take this style of
development to the extreme and formalize it. Should be fun and I'll figure out
what does and doesn't work as time goes on with STM as a whole. Time for a break
and then another session to do the saving of the blog entries.


#Pre-29

It has been the most insane past week. Things went south with our moving at the
last minute, so we spent a lot of time stabilizing and coming up with creative
solutions for everything. Ultimately we are here now in Bend and relatively
stable. I'll start regular work again on Tuesday. We still need an apartment,
and we are still house hunting, but we have finally settled into a safe routine.
We only have about a week of this though until things get hectic again while we
are finding an apartment. Now that I have some time, I'm going to try to squeeze
in a couple of sessions. I figure I'll try to finish up the blog and log writing
system. Would be a nice CLI tool to have. Once that is done, I can get back to
STM and actually convert the DEX logging and blogging CLI tool into a STM
project, which will give me a frame of reference to build around. STM is about
building services and DEX is providing a blog writing and work log writing
service, so it will be good to use that to solidify STM a bit. Time to start
coding again.


#28

I'm in the middle of moving from San Jose, CA, to Bend, OR. Today we are
finishing up our packing into our POD. Then tomorrow morning we are leaving.
After my walk today, I decided that I would love to be able to spend a 25 minute
session "blogging" instead of working so I can talk about concepts. So I decided
to start souping up the DEX site repo with the ability to write blog entries.
Funny story is that now I'm creating a CLI tool to do that so I took some code
from STM so I could make this blogging system work. The plan is to be able to
run `dex log` or `dex blog` and it will prompt for what is needed and save it as
it should. For work logs, it will save in the stream of work logs, and for blog
posts it will save in its own file. They probably need to be saved in a data
array with like timestamps in stuff, but I'd like to be able to blog and log
things regularly to keep active and transparent with everything I'm doing. I
only really had one session this morning, but I'm excited to spend some of this
time building my ability to document my journey to making DEX a success. I'll be
able to look back and also show off what I went through to get to where I want
to be. Time to go finish packing and moving boxes. Hopefully I can come back to
working after the move... perhaps on Sunday.


#27

I went to go try to stop gulp from crashing on a bad build and `gulp-plumber`
doesn't seem to be working right at all... which really sucks. I'm not sure
exactly what the problem is, but it is ridiculously frustrating. There is a
ticket on it, but it hasn't been touched yet:
https://github.com/floatdrop/gulp-plumber/issues/50. Apparently it doesn't work
properly with Gulp v4. Which is dumb... so somebody suggested wrapping it with
`watch-spawn` so I'll do that for now. I probably won't have enough time for
another session, so I'll just commit what I have and call the new pipeline good.


#Pre-27

So I didn't get the chance to work yesterday, but I'm doing it now. I have maybe
2 session real quick before I have to get back to working on things. Currently
sitting in the lobby of a medical place. I'll just focus on setting up all the
testing that I can and perhaps fix the gulp pipeline to stop erroring and
crashing.


#26

So I got sucked into figuring out how to do custom assertions with `should.js`
but I figured it out finally and now I just need to write a custom assertion for
this command and parameters assertion that I want to do so I can write the tests
more cleanly. Still lots to do, but it is breakfast and probably packing time.
I'll continue tomorrow.


#25

So I've added logging silencing so I can run tests properly. I was trying to
find a clean way to run multiple child processes of my testing framework, but it
won't support the pretty printing that I created with `rxt` so I may need to
spend some time updating `rxt` with a proper test runner that will handle a
large number of test files at the same time. It shouldn't be too bad, but we
shall see. Until then, the next thing I'll do is focus on adding testing for the
command parser to make sure that it is properly handling the parsing as I
expect. So that will be nice to have. I might add a should.js rule to have
prettier error printing when it is wrong and also not have to submit a full
object to the deepEqual assertion. Off for a break, probably one more before I
tackle breakfast and then start moving.


#24

That was an intense session actually. Lots of writing... my wrist hurts since I
don't write too much. But I've started really breaking down communication and
service fulfillment in the form of request/response. And I've got a lot of
questions and a lot of clarification I need, but in the end I think it is
driving me closer to understanding how to build a full blown service creation
platform. The goal of STM is to provide the ability for individuals to provide a
full scale service architecture that can be built in very little time, while
coming with a variety of quality of life features like testing, mocking, service
discovery, scaling, documentation, etc. To truly understanding providing a
service, I need to understand how services are initiated and how services
respond and affect the world. This is the essence of programming, which is
providing a service given X/Y input and having X/Y output to change the world in
some way. I have a theory that the single input and single output that is
function based programming is not enough to properly fulfill requests in an
intelligent manner and real life service fulfillment can be used to model that
better. We'll see in the future if my theories are correct... if they are, I can
provide a much more powerful platform as there will be a shared understanding
and pattern to follow to speed up service development. Perhaps I'm working
towards "Services as a Service"... not Software as a Service... perhaps a SaaS
2.0? Lol awesome... time for a break.


#Pre-24

Been a few days since I tackled things. While busy with work of course, I've
been doing a lot of theoretical pondering. I've taken some time to start
learning lambda calculus, turing machines, and computational theory in general.
This will definitely help me perfect my goals with DEX and with STM as a whole.
I've starting formulating some solid hypothesis around certain concepts and am
trying to truly understand the concept of turing complete, and the computing
limitations that exist and how to maximize them in our current understanding of
computation. Lots of fun stuff. Before I start doing some more coding, I need to
write down some hard notes in my "Spellbook" that I bought specifically for
designing big ideas. Particularly around communication and servicing theories
that I have. I may not have much time to code this weekend since we are moving
this coming Friday, but hopefully I can set myself up for some success in the
near future. I think I'm making solid progress on STM.


#23

Alright so I've removed `inquirer` added back `rxt` for testing, and I've also
added `winston` for logging. I am going to use that for controlling the logging
levels during testing... which there should be none. Next step is to finish that
logging control and then start adding more tests to the system. But I'm done for
the day... I'll tackle it again tomorrow.


#Pre-23

So before I start this next portion, I wanted to put down my new thoughts. This
is all a sign that I'm diving too deep into the rabbit hole and I need to stop
doing that. Instead of building my own prompt system, I'm going to push forward
and drop the focus on the error scenario. I'm shifting my focus because
prompting, logging, etc. is all side effect related, and my goal is to focus on
the business logic first. If there is an error then error, otherwise push
through. So I'm going to refactor, remove inquirer, setup RxJS 5, and then setup
testing properly. It's tough transforming from normal programming, to a more
"functional" approach that is mostly free of side effects on the inside and
pushes it all to the outside. But let's see how that goes moving forward.


#22

This is ridiculous. So I have attempted to tie in testing. At first using my own
library `rxt`. But I have discovered that I built `rxt` to use RxJS 5. However,
I have to use RxJS 4 because of Inquirer. And apparently you can't `mergeMap`
from an RxJS 4 Observable into an RxJS 5 Observable... which is a painful
problem. So I'm stuck. I tried to then setup testing using Ava, hoping that it
was capable of handling things, but apparently not the case at all. Same
problem that Ava uses RxJS 5, not 4. So `Inquirer` is the problem... what does
this mean? Well sounds like I need to write my own damn prompt library too that
supports RxJS 5. Luckily my needs right now aren't as drastic as what `Inquirer`
supplies, so perhaps it won't be so bad? It is just accepting `stdin` right?
**sigh** of course this can't be easy. Why would it be easy?


#Pre-22

So I was hoping to get around to a fourth session today, but got sucked into
work. I've been thinking. Right now I want to put testing around this system
because it really needs it so I can speed up the work. In order to do that
though I have to essentially run in "detached" mode so that way the prompt
system doesn't get triggered. So the expected behaviour will be that if the
required parameter does not exist for the command then in "detached" mode
instead of prompting you it will just emit a validation error. Woo fun. So
tomorrow I'll look into testing. Until then... night folks.


#21

Done refactoring out the command parser module. I've also added a path for
invalid requests. Now it is just a matter of using the invalid request and using
that to generate prompts to fill out the request until it is valid... shouldn't
be too bad. Right? Yeah probably going to not be too trivial, but I'll figure it out.


#20

Making solid progress. I've got the initial stream of a fully valid request
coming through properly, and have implemented JSON schema to ensure the request
is actually valid. Seems to be working swimmingly. The first thing I want to do
next session is refactore things a bit so this is a cleaner looking process.
Since it is mostly functional programming, adjusting the process is WAY faster
than regular imperative programming and it has been really great and fast to
adjust things. Refactoring should go swimmingly. Totally excited.


#19

Getting close, so I spent a bit of time debugging because I kept trying to use
`RxJS` 5... `Inquirer` doesn't like that, so I guess I'm stuck with `RxJS` 4.
Lame, I will probably replace the prompting system in the future, but for now
I'll deal I guess. Now that I fixed that, I need to get a system that allows me
to request required parameters if they are missing and then when everything is
said and done, send things through to the end of the command. Time for a break.


#Pre-19

Getting ready to jump into ideally 4 sessions tonight. So the goal is to get the
request validation portion at least basically setup. I want prompts to be used
to fill in the required portions if the required portions aren't already
provided. Hopefully working with `Inquirer` mixed with `rxjs` is smooth going.
We shall see. I saw a post in the past about someone who got infinite prompting
working with `Inquirer` so it should meet my needs at least until I deem
otherwise and can replace it later. This also means that I need to start
considering the program spec and what it will look like. AWAY!!!


#18

So I setup the initial observable stream and have setup the command parsing with
`minimist` and setup detecting the `sub-command` by grabbing the first unlabeled
parameter found by minimist and extracting that from the args as a sub-command.
I've also pulled that process out into a separate command parser so that command
parser can be re-used. The command parser will accept a program specification
which will include the sub-commands and their options and requirements and
stuff. So with that I'll start working on the prompting system that will check
for required parameters and if they don't exist then prompting for them. I also
need to start segmenting the smaller parts of the program, like parsing with
minimist. I want to be able to use the program spec to customize how `minimist`
takes in arguments. For example if a single letter argument is set to a
variable, but the program spec says it is a boolean, then it should extract that
into unlabeled and set the argument to true. Little things like that. Should be
easy. I want to be able to provide a full blown command parser, but I also want
to give people the option to construct their own command parser with each
individual part so I'll be exporting all of them in the module. Should be fairly
powerful.


#Pre-18

So between yesterday and today, I've been considering how to approach building
my own CLI processor in the form of a stream. In order to do that I've had to
think about breaking it up into multiple parts. Some of those parts could be
covered with other tech to make this easier. The first part is parsing out all
of the arguments. This is something that can be done by `minimist`. Next would
be to determine if a subcommand is trying to be run by analyzing the first of
the non-marked arguments (we are making the assumption of a single subcommand
per execution). Then when we know the command we can check against
required/optional parameters for that command, and if we are not running in
detached mode we prompt for each one. If we already have all requirements, don't
prompt for optionals, if we don't have all requirements when prompting for
required, also prompt for optionals. Once we have all the parameters then we
need to call the actual service with it. The service will yield data to intruct
on a side effect, then that data will be passed to the appropriate side effect
(be it file writing, logging, etc.). At any point if requirements are not met
and it "fails", error out and the error will result in showing the help for the
detected subcommand otherwise it will show it for the whole program.

I think I can work with that design. Now to start writing it. I won't have many
sessions today, probably only one. But starting is good.


#17

So it's ridiculous, but I'm working on designing a new CLI processor based on
streams. Seriously the rabbit hole keeps getting deeper and maybe one day I'll
dig myself out. During this project to provide a unified architecture/service
system I'm going to find a lot of things that aren't built to the way that will
enable everything to work, cleanly and in tandem with each other. The thing is,
things have to be converted into a truly data driven system. However I need to
make sure that I'm not restricting myself into a configuration heavy system,
which I don't think will happen considering that being able to stream process
things means that prior to making a call to a data driven system I can massage
the data into what it needs to be in a stream and then merge map into it. I
think... we shall see.


#16

So I'm not satisfied with dashdash or args parse honestly. dashdash set my
expectations for something like bash completion and clean type coercion, but I'm
just not satisfied. I have to walk on this. I was thinking about just using
minimist, but minimist doesn't have nice features like generated help, and what
not. I feel like there should really be an easier way for this, there has got to
be something I'm missing. Do I need to write my own CLI module built in Rx? It's
possible. Since I'm considering everything is a stream. I could use minimist to
parse our the arguments, but design my own system around subcommands, and then
pipe minimist results into a generated help, perhaps? Part of the problem with
minimist is the implicit arguments rather than explicit. I want explicit that
matches the "services" request parameters. Which I sort of liked commander for.
It's all dumb and just doesn't make sense. I'll figure something out. Time for a
walk to clear my mind.


#15

So while using Commander I discovered an unforgiving issue. Apparently if you
have an argument that matches any of the object properties of the commander
object, then you break the Commander object because your argument will replace
that property on Commander instead of being namespaced. There was a suggestion
to move to argsparse, so I'll take a look at that. Actually just looked at
dashdash and I like that he does an analysis of other CLI parsers and has much
better features like bash completion integration and what not... looks solid.
Good to be back and working on STM again after a busy crazy work week.


#14

So I'm dumb. I tried to create the program stream using a Subject instead of
just creating an Observable. So now that I've figured that out I can actually
move forward. I refactored the program into an observable now so I can create
command streams that spin off of that and merge them all together. Making
progress. I setup the help stream that catches when default is sent. The goal is
to figure out the best way to represent commands in a similar way as
representing a service in an HTTP system and then using that representation to
build subcommand around it. The CLI tool acts as an API gateway and the
subcommands are individual services. The arguments are the request parameters so
they can run through the same request validation as an HTTP request. Eventually
I want to see STM building itself... lol. But for now I've got to stop... gotta
go get some work done for my real job now. I'll tackle more soon.


#13

So my brain hurts. Trying to figure out the best way to turn the entire program
into a stream... but that isn't as easy as I thought it might be. If anything it
is giving me more experience with streams, which is something I can't argue
with. It is just frustrating. Ideally I have a directory of services and those
are dynamically loaded into the Commander program with description and
everything while linking to that directory's handler function to do the things,
but that isn't exactly working out the way I want. Looks like I'll have to let
this simmer throughout the day while I do work. Lame... :(


#12

Started exploring what it will take to turn the entire CLI into a stream of
commands and how to properly filter them and send them into eventual "service"
functions. I just want Commander to be an "API Gateway" for commands in a
similar pattern as I would do for the microservices it creates. So it is worth
exploring for a bit. I think I'll try one more session after this so that I can
commit something that works with streams.


#11

Didn't get the chance to work on STM yesterday, but this morning I'm popping in
a couple sessions. But it wasn't the best start. I get perfectionist when it
comes to making things presentable and I need to stop and start working on the
actual command. I just wanted a nice default and got sucked into trying to
figure out the intricacies of Commander. My bad. So next I actually will start
on the prompting system for the initialization of a project. I think I'll only
have one more session though as I need to get some Kasisto work done.


#10

I realized something major just recently, that STM can cover more ground than
was originally planned. I sat down and did a big picture session of design. This
design could lead to big things in the future, but I have to be VERY careful of
scope creep. I'm realizing that there is a lot of parallel in the tasks I'm
doing and a LARGE refactoring in common practices across the tech world is
necessary. A lot of tools that exist need to be rebuilt to handle this
refactoring, but it will be better in the end. This was a very interesting
session to say the least. I'd share, but then I can't build it myself. I'm more
than willing to be transparent, but I want to be able to take the time to build
the philosophy first.


#9

Started playing around with the help display of the command. Had to figure out
how to do a banner above the help output added in some indentation and what not.
My first main goal is to make sure that the documentation for this system is
clean and easy to parse. It needs to be intuitive and documented from the
beginning.


#8

So I've started creating the STM CLI. First thing first is setting up commander.
I also realized that I need to regularly compile my ES6 code into an executable
local STM, so I'm working on setting up a Gulp file now so that I can have my
changes be watched and automatically compiled into an executable and I'll
symlink the executable in the root directory so it is quick to test things
manually. Considering this first portion is just CLI options as input I don't
think I'll want automated testing for this, but when those settings get passed
into the inquirer portion which will handle prompting then I probably want to
look into something automated around there for filling in like defaults that
weren't provided by CLI options. We'll see. Time for the next break.


#7

Day #2 - starting by planning out the first STM command which will be `stm
init`. This will create the project directory structure of "services". "tools",
and "modules" and store the project settings in "./.root.json". These settings
exist to provide a path for idempotency as well as an easy upgrade path so
re-running a command can be re-run with past settings. This will be a common
pattern for all code generation in STM. I also did some research into how I
expect to do testing for STM so it remains stable. This is essentially a more
specific "Slush" so I've been looking into testing for gulp/slush. Hopefully
using a stream system with RxJS will make testing a bit easier. We'll see in the
second session of the day.


#6

Spent some time writing down initial details on STM and planning where to go
from here. Did a lot of research on Commander and Liftoff as well as their
dependencies. Liftoff would be nice to use if I want a config file, but I don't
think I will need one early on since the goal of STM is to provide an
opinionated approach first. Commander will be good to use as it will provide
solid help information that I can utilize as well as parsing of arguments and
parsing of those arguments. I can use those arguments as "pre-filling" in
inquirer prompts. I think I will take one more session of STM planning before
starting to build because I have to think of what commands to start with and how
they will interact. The goal is also to have STM be idempotent for safety sake
of affecting projects, so I'll have to consider how to do that well as well as
consider "upgrade" paths for projects using STM. For now I break for breakfast.


#5

So I've made STM easy to publish and it now is executable. I also had time to
setup babel and es6 with a build pipeline to only publish what I want it to
publish. Sure I could use like npm ignore, but I have to build babel somewhere
so I might as well copy the relevant files to the same distribution folder. Next
I need to look at commander and making STM an actual CLI tool with commands and
everything. I may have to look at other CLI packages and stuff, but commander
will be a good place to start looking.


#4

So I was going to make STM executable, but then realized that I wanted a quick
way to publish STM. I had to play around with a couple of configurations and end
on a simple bash script that runs a `patch` run script and then runs `npm
publish`. I had to do it seprately because prepublish took the version it was
ran with rather than the new version created by the `patch` script. Oh well. So
now I can publish quickly, which means the next session I will make it
installable and executable. Time to learn how to setup a `bin` script for a node
package.


#3

Third session was about setting up the first major product provided by DEX...
STM (https://www.npmjs.com/package/s-t-m). STM stands for "Services, Tools,
Modules" and the goal of it is to be able to build microservice architectures
super quickly... like in an hour and pushed to production. I believe this can be
done efficiently following a specific set of opinionated software engienering
principles without sacrificing quality and flexibility in growth. I think the
next session is trying to get it executable.


#2

Second sesssion now done. I've setup the Github organization, checked various
social media channels to make sure the username of DevelopEXp was available.
Trying to get DEX everywhere would be near impossible so I've settled for
DevelopEXp everywhere. I've also started the public site for this, starting with
a simple HTML webpage. Time for my 5 minute break (working in pomodoro schedule
of 25 on and 5 off).


#1

My first 25 minute session working on DEX included me writing out the initial
ideas, goals, names, etc. in my fancy notebook that I got to build a startup.
I'm excited to start building this idea, 25 minutes at a time and blogging the
whole way through.
