#13

So my brain hurts. Trying to figure out the best way to turn the entire program
into a stream... but that isn't as easy as I thought it might be. If anything it
is giving me more experience with streams, which is something I can't argue
with. It is just frustrating. Ideally I have a directory of services and those
are dynamically loaded into the Commander program with description and
everything while linking to that directory's handler function to do the things,
but that isn't exactly working out the way I want. Looks like I'll have to let
this simmer throughout the day while I do work. Lame... :(


#12

Started exploring what it will take to turn the entire CLI into a stream of
commands and how to properly filter them and send them into eventual "service"
functions. I just want Commander to be an "API Gateway" for commands in a
similar pattern as I would do for the microservices it creates. So it is worth
exploring for a bit. I think I'll try one more session after this so that I can
commit something that works with streams.


#11

Didn't get the chance to work on STM yesterday, but this morning I'm popping in
a couple sessions. But it wasn't the best start. I get perfectionist when it
comes to making things presentable and I need to stop and start working on the
actual command. I just wanted a nice default and got sucked into trying to
figure out the intricacies of Commander. My bad. So next I actually will start
on the prompting system for the initialization of a project. I think I'll only
have one more session though as I need to get some Kasisto work done.


#10

I realized something major just recently, that STM can cover more ground than
was originally planned. I sat down and did a big picture session of design. This
design could lead to big things in the future, but I have to be VERY careful of
scope creep. I'm realizing that there is a lot of parallel in the tasks I'm
doing and a LARGE refactoring in common practices across the tech world is
necessary. A lot of tools that exist need to be rebuilt to handle this
refactoring, but it will be better in the end. This was a very interesting
session to say the least. I'd share, but then I can't build it myself. I'm more
than willing to be transparent, but I want to be able to take the time to build
the philosophy first.


#9

Started playing around with the help display of the command. Had to figure out
how to do a banner above the help output added in some indentation and what not.
My first main goal is to make sure that the documentation for this system is
clean and easy to parse. It needs to be intuitive and documented from the
beginning.


#8

So I've started creating the STM CLI. First thing first is setting up commander.
I also realized that I need to regularly compile my ES6 code into an executable
local STM, so I'm working on setting up a Gulp file now so that I can have my
changes be watched and automatically compiled into an executable and I'll
symlink the executable in the root directory so it is quick to test things
manually. Considering this first portion is just CLI options as input I don't
think I'll want automated testing for this, but when those settings get passed
into the inquirer portion which will handle prompting then I probably want to
look into something automated around there for filling in like defaults that
weren't provided by CLI options. We'll see. Time for the next break.


#7

Day #2 - starting by planning out the first STM command which will be `stm
init`. This will create the project directory structure of "services". "tools",
and "modules" and store the project settings in "./.root.json". These settings
exist to provide a path for idempotency as well as an easy upgrade path so
re-running a command can be re-run with past settings. This will be a common
pattern for all code generation in STM. I also did some research into how I
expect to do testing for STM so it remains stable. This is essentially a more
specific "Slush" so I've been looking into testing for gulp/slush. Hopefully
using a stream system with RxJS will make testing a bit easier. We'll see in the
second session of the day.


#6

Spent some time writing down initial details on STM and planning where to go
from here. Did a lot of research on Commander and Liftoff as well as their
dependencies. Liftoff would be nice to use if I want a config file, but I don't
think I will need one early on since the goal of STM is to provide an
opinionated approach first. Commander will be good to use as it will provide
solid help information that I can utilize as well as parsing of arguments and
parsing of those arguments. I can use those arguments as "pre-filling" in
inquirer prompts. I think I will take one more session of STM planning before
starting to build because I have to think of what commands to start with and how
they will interact. The goal is also to have STM be idempotent for safety sake
of affecting projects, so I'll have to consider how to do that well as well as
consider "upgrade" paths for projects using STM. For now I break for breakfast.


#5

So I've made STM easy to publish and it now is executable. I also had time to
setup babel and es6 with a build pipeline to only publish what I want it to
publish. Sure I could use like npm ignore, but I have to build babel somewhere
so I might as well copy the relevant files to the same distribution folder. Next
I need to look at commander and making STM an actual CLI tool with commands and
everything. I may have to look at other CLI packages and stuff, but commander
will be a good place to start looking.


#4

So I was going to make STM executable, but then realized that I wanted a quick
way to publish STM. I had to play around with a couple of configurations and end
on a simple bash script that runs a `patch` run script and then runs `npm
publish`. I had to do it seprately because prepublish took the version it was
ran with rather than the new version created by the `patch` script. Oh well. So
now I can publish quickly, which means the next session I will make it
installable and executable. Time to learn how to setup a `bin` script for a node
package.


#3

Third session was about setting up the first major product provided by DEX...
STM (https://www.npmjs.com/package/s-t-m). STM stands for "Services, Tools,
Modules" and the goal of it is to be able to build microservice architectures
super quickly... like in an hour and pushed to production. I believe this can be
done efficiently following a specific set of opinionated software engienering
principles without sacrificing quality and flexibility in growth. I think the
next session is trying to get it executable.


#2

Second sesssion now done. I've setup the Github organization, checked various
social media channels to make sure the username of DevelopEXp was available.
Trying to get DEX everywhere would be near impossible so I've settled for
DevelopEXp everywhere. I've also started the public site for this, starting with
a simple HTML webpage. Time for my 5 minute break (working in pomodoro schedule
of 25 on and 5 off).


#1

My first 25 minute session working on DEX included me writing out the initial
ideas, goals, names, etc. in my fancy notebook that I got to build a startup.
I'm excited to start building this idea, 25 minutes at a time and blogging the
whole way through.
